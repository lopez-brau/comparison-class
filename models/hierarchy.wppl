// set up the ontological tree with basic ontologies
var ontologies = [ 
	{
		category: "ALL THINGS", 
		parent: null, 
		children: ["THINGS WITH SPATIAL LOCATION", "ABSTRACT OBJECTS"] 
	},
	{ 
		category: "THINGS WITH SPATIAL LOCATION", 
		parent: "ALL THINGS",
		children: ["PHYSICAL OBJECTS", "EVENTS"]
	},
	{
		category: "ABSTRACT OBJECTS",
		parent: "ALL THINGS",
		children: []
	},
	{ 
		category: "PHYSICAL OBJECTS", 
		parent: "THINGS WITH SPATIAL LOCATION",
		children: ["SOLID OBJECTS", "AGGREGATES"] 
	}, 
	{ 
		category: "EVENTS", 
		parent: "THINGS WITH SPATIAL LOCATION",
		children: []
	},
	{ 
		category: "SOLID OBJECTS", 
		parent: "PHYSICAL OBJECTS",
		children: ["LIVING THINGS", "FUNCTIONAL ARTIFACTS"] 
	},
	{ 
		category: "AGGREGATES", 
		parent: "PHYSICAL OBJECTS",
		children: [] 
	}, 
	{ 
		category: "LIVING THINGS", 
		parent: "SOLID OBJECTS",
		children: ["ANIMALS", "PLANTS"] 
	}, 
	{ 
		category: "FUNCTIONAL ARTIFACTS", 
		parent: "SOLID OBJECTS",
		children: [] 
	}, 
	{ 
		category: "ANIMALS", 
		parent: "LIVING THINGS",
		children: [] 
	}, 
	{ 
		category: "PLANTS", 
		parent: "LIVING THINGS",
		children: [] 
	},
]

// pre-condition: a category/kind, its parent in the tree, and an empty array for future children
// post-condition: a new node in the tree with the provided arguments and updated parent node
var makeNode = function(args) {
	// creates and pushes a node to the tree
	var node = {
		category: args[0],
		parent: args[1],
		children: args[2]
	}
	ontologies.push(node)

	// update the parent node
	_.where(ontologies, {category: args[1]})[0].children.push(args[0])

	return ontologies
}

// creates nodes of categories/kinds; can possibly instantiate priors/prior weights here
makeNode(["humans", "ANIMALS", []])
makeNode(["parties", "EVENTS", []])
makeNode(["phones", "FUNCTIONAL ARTIFACTS", []])
makeNode(["rocks", "SOLID OBJECTS", []])
makeNode(["dogs", "ANIMALS", []])

// bins for discretizing distributions
var bins = _.range(-2, 12, 0.5)

// pre-condition: the mean and variance of the desired Gaussian distribution
// post-condition: returns a discrete version of a Gaussian distribution
var discreteGaussian = function(args) {
	var mu = args[0]
	var sigma = args[1]
	var discreteProbs = map(function(b) {
		return Math.exp(Gaussian({mu: mu, sigma: sigma}).score(b))
	}, bins)
	return Infer({method: 'enumerate'}, function() {
		categorical({ps: discreteProbs, vs: bins})
	})
}

// stores the prior distributions of various kinds over features
var featurePriors = {
	height: {
		humans: discreteGaussian(1, 1),
		parties: discreteGaussian(4, 1),
		phones: discreteGaussian(7, 1),
		rocks: discreteGaussian(10, 1),
		dogs: discreteGaussian(3, 1)
	}
}

// set up an array to store the kinds in the tree
var kinds = []
var prior = []

// pre-condition: a character
// post-condition: returns 0 if the character is lowercase, 1 otherwise
var isLower = function(char) {
	return char === char.toLowerCase() ? 0 : 1
}

// recursively traverses through the tree, finding and storing the kinds
// pre-condition: a node (category or kind) and feature
// post-condition: the mixed prior distribution of the node over a feature
var getPrior = function(node, feat) {
	// if there is no node, then return
	if (_.isEmpty(node)) { return } 

	// variable for storing the object of the current node
	var currentNode = _.where(ontologies, {category: cat})[0]

	// applies recursion to every child of the current node
	map(getPrior, currentNode.children)
	
	// if a node does not have children...
	if (!_.isEmpty(currentNode.children)) {
		// ...and if it is a kind, push the kind onto the kinds array
		if (sum(map(isLower, node)) === 0) { 
			kinds.push(node)
			return
		} 

		// ...and if it is a category, it does not have any priors either so return
		return
	}

	// else, the node has children and we can mix the priors up to this node
	if (kinds.length !== 0) {
		prior.push(mixPriors(node, feat, kinds))

		// pop off the kinds that were just mixed
		repeat(kinds.length, function() {
			return kinds.pop()
		})

		return
	}

	return
}

// pre-condition: an array of kinds
// post-condition: determines the weights on the prior distributions of the kinds before mixing
var priorWeights = function(kin) {
	return repeat(kin.length, function() {
		return 1
	})
}

// pre-condition:
// post-condition: 
var mixPriors = function(cat, feat, kin) {
	return Infer({method: 'enumerate'}, function() {
		var whichKind = categorical({vs: kinds, ps: priorWeights(kinds)})
		return sample(featurePriors.feat[whichKind]) // height object is temporary
	})
}

getPrior("ANIMALS", "height")
//getPrior("SOLID OBJECTS", k)
prior
